plugins {
    id 'dev.architectury.loom' version '1.10-SNAPSHOT' apply false
    id 'architectury-plugin' version '3.4-SNAPSHOT'
    id 'com.github.johnrengelman.shadow' version '8.1.1' apply false
    id 'io.freefair.lombok' version '8.10' apply false
    id 'com.github.gmazzo.buildconfig' version '5.4.0' apply false
    id 'idea'
    id 'java'
    id 'org.jreleaser' version '1.13.1' apply false
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.7'
}

architectury {
    minecraft = project.minecraft_version
}

allprojects {
    group = rootProject.maven_group
    version = rootProject.mod_version
}

subprojects {
    apply plugin: 'dev.architectury.loom'
    apply plugin: 'architectury-plugin'
    apply plugin: 'io.freefair.lombok'

    if (!project.name.startsWith("testing")) {
        apply plugin: 'org.jreleaser'
        apply plugin: 'maven-publish'
    }

    idea {
        module {
            downloadJavadoc = true
        }
    }

    if (!project.name.endsWith("common")) {
        apply plugin: 'com.github.johnrengelman.shadow'
    } else {
        apply plugin: 'com.github.gmazzo.buildconfig'
    }

    ext {
        var nameSeparatorIndex = project.path.lastIndexOf('-')
        var nameOffset = project.path.startsWith(':') && nameSeparatorIndex > 0 ? 1 : 0

        module_name = project.path.substring(nameOffset, nameSeparatorIndex == -1 ? project.path.length() : nameSeparatorIndex)
        mod_id = "${rootProject.archives_name}_$module_name"
        module_type = project.name.substring(project.name.lastIndexOf('-') + 1)
    }

    architectury {
        if (!project.name.endsWith("common")) {
            platformSetupLoomIde()
        } else {
            common rootProject.enabled_platforms.split(',')
        }

        if (project.name.endsWith("fabric")) {
            fabric()
        }

        if (project.name.endsWith("neoforge")) {
            neoForge()
        }
    }

    loom {
        enableTransitiveAccessWideners = true

        runs {
            configureEach {
                ideConfigGenerated(true)
                vmArg("-Dmixin.env.remapRefMap=true")
                vmArg("-Dmixin.env.refMapRemappingFile=${projectDir}/build/createSrgToMcp/output.srg")
            }
        }

        runConfigs.each {
            if (!project.name.startsWith("testing")) {
                it.setIdeConfigGenerated(false)
            } else {
                it.runDir = "../run/$it.environment"
            }
        }

        mixin {
            useLegacyMixinAp = false
        }

        interfaceInjection {
            enableDependencyInterfaceInjection = true
        }
    }

    base {
        archivesName = "$rootProject.archives_name-$project.name"
    }

    if (project.name.endsWith("common")) {
        configurations {
            named
        }

        task apiJar(type: Jar) {
            archiveClassifier.set('api')
            from sourceSets.main.output
        }

        artifacts {
            named apiJar
        }
    }

    if (!project.name.endsWith("common")) {
        configurations {
            common {
                canBeResolved = true
                canBeConsumed = false
            }
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common

            if (project.name.endsWith("fabric")) {
                developmentFabric.extendsFrom common
            }

            if (project.name.endsWith("neoforge")) {
                developmentNeoForge.extendsFrom common
            }

            shadowBundle {
                canBeResolved = true
                canBeConsumed = false
            }
        }
    }

    repositories {
        // NeoForged repository only added when needed
        if (project.name.endsWith("neoforge")) {
            maven {
                name = 'NeoForged'
                url = 'https://maven.neoforged.net/releases'
            }
        }

        // Using official mappings instead of Parchment

        exclusiveContent {
            forRepository {
                maven {
                    name = "Modrinth"
                    url = "https://api.modrinth.com/maven"
                }
            }
            filter {
                includeGroup "maven.modrinth"
            }
        }

        mavenCentral()
    }

    dependencies {
        minecraft "net.minecraft:minecraft:$rootProject.minecraft_version"

        // Using official Mojang mappings only
        mappings loom.officialMojangMappings()

        if (project.name.endsWith("common")) {
            modImplementation "net.fabricmc:fabric-loader:$rootProject.fabric_loader_version"
            modImplementation "dev.architectury:architectury:$rootProject.architectury_api_version"
        }

        if (project.name.endsWith("fabric")) {
            modImplementation "net.fabricmc:fabric-loader:$rootProject.fabric_loader_version"
            modImplementation "net.fabricmc.fabric-api:fabric-api:$rootProject.fabric_api_version"
            modImplementation "dev.architectury:architectury-fabric:$rootProject.architectury_api_version"

            common(project(path: ":$project.module_name-common", configuration: 'namedElements')) { transitive false }
            shadowBundle project(path: ":$project.module_name-common", configuration: 'transformProductionFabric')
        }

        if (project.name.endsWith("neoforge")) {
            neoForge "net.neoforged:neoforge:$rootProject.neoforge_version"
            modImplementation "dev.architectury:architectury-neoforge:$rootProject.architectury_api_version"

            common(project(path: ":$project.module_name-common", configuration: 'namedElements')) { transitive false }
            shadowBundle project(path: ":$project.module_name-common", configuration: 'transformProductionNeoForge')
        }
    }

    java {
        withSourcesJar()
        withJavadocJar()
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
        toolchain {
            languageVersion = JavaLanguageVersion.of(21)
        }
    }

    javadoc.options.addStringOption('Xdoclint:none', '-quiet')

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
        options.release = 21
        options.incremental = true
        options.fork = true
    }

    if (!project.name.endsWith("common")) {
        processResources {
            if (project.name.endsWith("neoforge")) {
                def placeholders = [
                        version: project.version,
                        mod_id: project.mod_id,
                        mod_name: "$mod_display_name - ${project.module_name.capitalize()}",
                        architectury_version: architectury_api_version,
                        minecraft_version: minecraft_version,
                        license: "GPLv3"
                ]

                inputs.properties(placeholders)

                filesMatching('META-INF/neoforge.mods.toml') {
                    expand placeholders
                }
            } else if (project.name.endsWith("fabric")) {
                def placeholders = [
                        version: project.version,
                        mod_id: project.mod_id,
                        mod_name: "$mod_display_name - ${project.module_name.capitalize()}",
                        architectury_version: architectury_api_version,
                        minecraft_version: minecraft_version,
                        fabric_loader_version: fabric_loader_version,
                        license: "GPLv3"
                ]

                inputs.properties(placeholders)

                filesMatching('fabric.mod.json') {
                    expand placeholders

                    if (!project.name.startsWith("testing")) {
                        filter { String line ->
                            if (line.contains('"mixins":')) {
                                var modifiedLine = "  \"accessWidener\": \"${project.mod_id}.accesswidener\",\n" + line
                                return modifiedLine
                            }
                            return line
                        }
                    }
                }
            }
        }

        shadowJar {
            configurations = [project.configurations.shadowBundle]
            archiveClassifier = 'dev-shadow'
        }

        remapJar {
            input.set shadowJar.archiveFile
            dependsOn shadowJar
        }

        configurations {
            named
        }
    }

    if (project.name.endsWith("common")) {
        buildConfig {
            className("ModuleConstants")
            packageName(project.group + ".${rootProject.name}.$project.module_name")
            useJavaOutput()
            buildConfigField(String, "MOD_ID", "$project.mod_id")
        }
    }

    if (!project.name.endsWith("common")) {
        task copyJar(type: Copy) {
            from remapJar
            into "${rootProject.projectDir}/build/${module_type}"
            dependsOn remapJar
        }

        build.dependsOn copyJar
    }

    if (!project.name.startsWith("testing")) {
        jreleaser {
            gitRootSearch = true

            signing {
                active = 'ALWAYS'
                armored = true
            }

            deploy {
                maven {
                    mavenCentral {
                        sonatype {
                            active = 'ALWAYS'
                            url = 'https://central.sonatype.com/api/v1/publisher'
                            stagingRepository('build/staging-deploy')
                        }
                    }
                }
            }
        }

        publishing {
            publications {
                mavenJava(MavenPublication) {
                    artifactId base.archivesName.get()
                    from components.java
                    if (project.tasks.findByName("apiJar")) {
                        artifact apiJar
                    }

                    pom {
                        name = "$mod_display_name - ${project.module_name.capitalize()}"
                        description = "An Open Source Minecraft Modding Library"

                        licenses {
                            license {
                                name = "GNU General Public License 3"
                                url = "https://www.gnu.org/licenses/gpl-3.0.html"
                            }
                        }

                        developers {
                            developer {
                                id = 'Skillfi'
                                name = 'Alex'
                            }
                        }
                    }
                }
            }

            repositories {
                maven {
                    name = "cloudsmith"
                    def releasesRepoUrl = "https://maven.cloudsmith.io/solusmods/eternalcore/"
                    def snapshotsRepoUrl = "https://maven.cloudsmith.io/solusmods/eternalcore/"
                    url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
                    credentials {
                        username = System.getenv().getOrDefault("CLOUDSMITH_LOGIN", "skillfi")
                        password = System.getenv().getOrDefault("CLOUDSMITH_API", "2b95bc275979eb40ff0272a414150deac71ceee9")
                    }
                }
            }
        }

        tasks.publish.doFirst {
            def dir = file(layout.buildDirectory.dir("jreleaser"))
            dir.mkdirs()
        }
    }

    task refreshIdea(type: Delete) {
        delete project.file('.idea')
        delete project.file('*.iml')
        delete project.file('*.ipr')
        delete project.file('*.iws')
    }
}