package io.github.solusmods.eternalcore.command;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import com.mojang.brigadier.builder.ArgumentBuilder;
import io.github.solusmods.eternalcore.api.command.parameter.primitive.EnumArg;
import lombok.RequiredArgsConstructor;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import org.jetbrains.annotations.Nullable;

import java.lang.annotation.Annotation;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class CommandArgumentRegistry {
    private final Table<Class<?>, Class<? extends Annotation>, CommandArgumentFactory<? extends Annotation, ?>> ARGUMENT_FACTORIES = Tables.synchronizedTable(HashBasedTable.create());

    /**
     * Register a new argument annotation.
     *
     * @param argumentType       The class of the argument parameter.
     * @param argumentAnnotation The annotation class.
     * @param factory            The factory to create command nodes for the argument.
     */
    public <P, T extends Annotation> void register(Class<P> argumentType, Class<T> argumentAnnotation, CommandArgumentFactory<T, P> factory) {
        ARGUMENT_FACTORIES.put(argumentType, argumentAnnotation, factory);
    }

    /**
     * Utility method to register a new enum argument.
     *
     * @param enumClass The enum class to register.
     */
    public <T extends java.lang.Enum> void registerEnum(Class<T> enumClass) {
        register(enumClass, EnumArg.class, (annotation, handler) -> {
            for (var constant : enumClass.getEnumConstants()) {
                handler.addNode(Commands.literal(constant.name()));
                handler.addValueExtractorToLastNode(context -> constant);
            }
        });
    }

    @Nullable
    public <P, T extends Annotation> CommandArgumentFactory<T, P> get(Class<P> type, Class<T> annotation) {
        return (CommandArgumentFactory<T, P>) ARGUMENT_FACTORIES.get(type, annotation);
    }

    @FunctionalInterface
    public interface CommandArgumentFactory<T extends Annotation, P> {
        void create(final T annotation, ArgumentNodeHandler<P> handler);
    }

    @RequiredArgsConstructor
    public static class ArgumentNodeHandler<T> {
        private final List<ArgumentBuilder<CommandSourceStack, ?>> newNodes;
        private final ArgumentHandlerIndexApplier argumentHandlerIndexApplier;
        private final ArgumentHandlerApplier argumentHandlerApplier;
        private final AtomicBoolean allowConsole;
        private final String argumentName;
        private int lastNodeIndex = -1;

        public void addValueExtractor(CommandAnnotationHandler.CommandNode.ParameterSupplier<T> valueExtractor) {
            argumentHandlerApplier.apply(valueExtractor::get);
        }

        public void addValueExtractorToLastNode(CommandAnnotationHandler.CommandNode.ParameterSupplier<T> valueExtractor) {
            argumentHandlerIndexApplier.apply(lastNodeIndex, valueExtractor::get);
        }

        public void addNode(ArgumentBuilder<CommandSourceStack, ?> node) {
            lastNodeIndex = newNodes.size();
            newNodes.add(node);
        }

        public void preventConsoleUsage() {
            allowConsole.set(false);
        }

        public String getAutoGeneratedArgumentName() {
            return this.argumentName;
        }

        public interface ArgumentHandlerIndexApplier {
            void apply(int index, CommandAnnotationHandler.CommandNode.ParameterSupplier<Object> value);
        }

        public interface ArgumentHandlerApplier {
            void apply(CommandAnnotationHandler.CommandNode.ParameterSupplier<Object> value);
        }
    }
}
